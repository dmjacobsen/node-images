/*
 *
 *  MIT License
 *
 *  (C) Copyright 2022 Hewlett Packard Enterprise Development LP
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included
 *  in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 *  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *  OTHER DEALINGS IN THE SOFTWARE.
 *
 */
@Library('csm-shared-library@main') _

/* General Notes

    The general flows of this Jenkinsfiel are as follows:
    - If not building on a tag, all the images are built except for the base image to save time.
    - If not building on a tag, the common image and its derivates must build.
    - If not building on a tag, a google and metal image must be built and published together.
    - If building on a tag, nothing is built; building on a tag should promote the current HASH of the branch to a pre-release or release (depending on the tag).
    
    NOTE: Until the PIT Common layer produces an ISO it is skipped, it takes time to build and isn't used at all in its current form.
 */

// Release toggles; define stable, and when to rebuild from a stable branch.
def promotionToken = ~"(master|main|develop|lts\\/.*)"
def buildAndPublish = env.TAG_NAME == null && !(env.BRANCH_NAME ==~ promotionToken) ? true : false
def sourceBuildVersion = '[RELEASE]' // Pulls the latest release

// Rebuild toggles; never build base unless explicitly required, always rebuild common.
def rebuildBaseImage = env.TAG_NAME == null ? true : false
def rebuildCommonImage = env.TAG_NAME == null ? true : false

// Temporary toggles; useful for certain contexts.
def disablePIT = false

// Disable pr-merge builds; node-image pipeline doesn't use the PR images at all.
if (env.BRANCH_NAME ==~ ~"^PR-\\d+") {
    currentBuild.result = 'SUCCESS'
    echo "Pull-Requests are not built for node-image-build; this is a no-op build."
    return
}

pipeline {
    agent {
        label "metal-gcp-builder-large"
    }

    options {
        buildDiscarder(logRotator(daysToKeepStr: "30", artifactDaysToKeepStr: "2"))
        timestamps()
        disableConcurrentBuilds()
    }

    environment {
        ARTIFACTS_DIRECTORY_BASE = "output-sles15-base"
        ARTIFACTS_DIRECTORY_CEPH = "output-ncn-node-images/storage-ceph"
        ARTIFACTS_DIRECTORY_COMMON = "output-ncn-common"
        ARTIFACTS_DIRECTORY_K8S = "output-ncn-node-images/kubernetes"
        ARTIFACTS_DIRECTORY_PIT = "output-pit"
        ISO = "SLE-15-SP3-Online-x86_64-GM-Media1.iso"
        ISO_URL = "https://artifactory.algol60.net/artifactory/os-images"
        NPROC = sh(returnStdout: true, script: "nproc").trim()
        NRAM = '8196'
        STABLE_BASE = "https://artifactory.algol60.net/artifactory/csm-images/stable"
        VERSION = setImageVersion(commitHashShort: GIT_COMMIT[0..6])
    }

    parameters {
        booleanParam(name: 'buildAndPublish', defaultValue: buildAndPublish, description: 'Whether or not main, develop, lts/*, or git-tags should rebuild their current HASH. When unchecked these branches and git-tags will only verify their hash has been promoted.')
        booleanParam(name: 'disablePIT', defaultValue: disablePIT, description: 'Whether the PIT image should not be built, this can be useful if builds are taking a long time or failing')
        booleanParam(name: 'rebuildBaseImage', defaultValue: rebuildBaseImage, description: 'If disabled, the common layer will build on the latest stable base image in Artifactory. If enabled, the base image will be rebuilt fresh. This layer DOES NOT need to build for publishing to succeed after a git-tag.')
        booleanParam(name: 'rebuildCommonImage', defaultValue: rebuildCommonImage, description: 'If disabled, the child images (Kubernetes & Storage-CEPH) will built atop the latest stable common image in Artifactory. If enabled, the common image will be rebuilt fresh. This layer needs to build for publishing to succeed after a git-tag.')
        string(name: 'googleSourceImageProjectId', defaultValue: "artifactory-202004", description: 'The source Project ID for pulling Google images.')
    }

    stages {
        stage('Setup') {
            parallel {
                stage('autoinst.xml') {
                    when {
                        expression { env.TAG_NAME == null && (!(env.BRANCH_NAME ==~ promotionToken) || (env.BRANCH_NAME ==~ promotionToken && params.buildAndPublish)) }
                        expression { params.rebuildBaseImage }
                    }
                    steps {
                        withCredentials([
                                string(credentialsId: 'sles15-initial-root-password', variable: 'SLES15_INITIAL_ROOT_PASSWORD'),
                                string(credentialsId: 'sles15-registration-code', variable: 'SLES15_REGISTRATION_CODE'),
                        ]) {
                            script {
                                sh './scripts/setup.sh'
                            }
                        }
                    }
                }
                stage('Fetch ISO') {
                    when {
                        expression { env.TAG_NAME == null && (!(env.BRANCH_NAME ==~ promotionToken) || (env.BRANCH_NAME ==~ promotionToken && params.buildAndPublish)) }
                        expression { params.rebuildBaseImage }
                    }
                    steps {
                        script {
                            dir('iso') {
                                script {
                                    httpRequest(authentication: 'artifactory-algol60', outputFile: "${ISO}", responseHandle: 'NONE', url: "${env.ISO_URL}/${env.ISO}")
                                }
                            }
                        }
                    }
                }
            }
        }
        stage('Base Layers') {
            when {
                expression { env.TAG_NAME == null && (!(env.BRANCH_NAME ==~ promotionToken) || (env.BRANCH_NAME ==~ promotionToken && params.buildAndPublish)) }
                expression { params.rebuildBaseImage }
            }
            parallel {
                stage('SLES') {
                    steps {
                        withCredentials([
                                file(credentialsId: 'google-image-manager', variable: 'GOOGLE_CLOUD_SA_KEY'),
                                string(credentialsId: 'sles15-initial-root-password', variable: 'SLES15_INITIAL_ROOT_PASSWORD')
                        ]) {
                            script {
                                def arguments
                                arguments = "-except=virtualbox-iso.* -var 'source_iso_uri=iso/${env.ISO}' -var 'ssh_password=${SLES15_INITIAL_ROOT_PASSWORD}' -var 'cpus=${NPROC}' -var 'memory=${NRAM}' -var 'artifact_version=${VERSION}'"
                                publishCsmImages.build(arguments, 'boxes/sles15-base/')
                                publishCsmImages.prepareArtifacts(ARTIFACTS_DIRECTORY_BASE, VERSION)
                                publishCsmImages.prepareArtifacts("${env.ARTIFACTS_DIRECTORY_BASE}-google", VERSION)
                                props = "build.number=${env.VERSION};build.url=${env.BUILD_URL};vcs.revision-short=${GIT_COMMIT[0..6]};build.source-artifact=${env.ISO_URL}/${env.ISO}"
                                publishCsmImages(pattern: ARTIFACTS_DIRECTORY_BASE, imageName: 'sles15-base', version: env.VERSION, props: props)
                                sh './scripts/google/import.sh'
                            }
                        }
                    }
                }
            }
        }
        stage('Common Layers') {
            when {
                expression { env.TAG_NAME == null && (!(BRANCH_NAME ==~ promotionToken) || (BRANCH_NAME ==~ promotionToken && params.buildAndPublish)) }
                expression { params.rebuildCommonImage }
            }
            parallel {
                stage('Non-Compute Common') {
                    when {
                        expression { params.rebuildCommonImage }
                    }
                    steps {
                        withCredentials([
                                string(credentialsId: 'sles15-initial-root-password', variable: 'SLES15_INITIAL_ROOT_PASSWORD'),
                                usernamePassword(credentialsId: 'artifactory-algol60', usernameVariable: 'ARTIFACTORY_USER', passwordVariable: 'ARTIFACTORY_TOKEN'),
                                file(credentialsId: 'google-image-manager', variable: 'GOOGLE_APPLICATION_CREDENTIALS'),
                                file(credentialsId: 'google-image-manager', variable: 'GOOGLE_CLOUD_SA_KEY')
                        ]) {
                            script {

                                def base = "sles15-base"
                                def googleSourceArtifact = "vshasta-${base}-${VERSION}"
                                def googleSourceImageFamily = "vshasta-${base}"
                                def sourceImage = "${base}-${VERSION}"
                                def arguments
                                def props
                                def source = "${ARTIFACTS_DIRECTORY_BASE}/${sourceImage}"

                                if (!params.rebuildBaseImage) {
                                    source = "${STABLE_BASE}/${base}/${java.net.URLEncoder.encode("${sourceBuildVersion}", "UTF-8")}/${base}-${java.net.URLEncoder.encode("${sourceBuildVersion}", "UTF-8")}"
                                    if (sourceBuildVersion != "[RELEASE]") {
                                        source = nodeImageHelpers.getArtifactorySourceArtifactFromId(source, sourceBuildVersion)
                                        googleSourceArtifact = nodeImageHelpers.getGoogleCloudSourceArtifactFromId(googleSourceImageFamily, sourceBuildVersion)
                                    } else {
                                        googleSourceArtifact = getGoogleCloudSourceArtifact(
                                                googleCloudSaKey: GOOGLE_CLOUD_SA_KEY,
                                                googleCloudProject: params.googleSourceImageProjectId,
                                                googleCloudFamily: googleSourceImageFamily
                                        )
                                    }
                                    dir("${env.ARTIFACTS_DIRECTORY_BASE}") {
                                        httpRequest(authentication: 'artifactory-algol60', outputFile: "${sourceImage}.qcow2", responseHandle: 'NONE', url: "${source}.qcow2")
                                    }
                                }

                                arguments = "-except=virtualbox-ovf.* -var 'google_source_image_name=${googleSourceArtifact}' -var 'source_iso_uri=${env.ARTIFACTS_DIRECTORY_BASE}/${sourceImage}.qcow2' -var 'ssh_password=${SLES15_INITIAL_ROOT_PASSWORD}' -var 'artifactory_user=${ARTIFACTORY_USER}' -var 'artifactory_token=${ARTIFACTORY_TOKEN}' -var 'cpus=${NPROC}' -var 'memory=${NRAM}' -var 'artifact_version=${VERSION}'"
                                publishCsmImages.build(arguments, 'boxes/ncn-common/')
                                publishCsmImages.prepareArtifacts(ARTIFACTS_DIRECTORY_COMMON, VERSION)

                                props = "build.number=${env.VERSION};build.url=${env.BUILD_URL};vcs.revision-short=${GIT_COMMIT[0..6]};build.source-artifact=${source}"
                                publishCsmImages(pattern: ARTIFACTS_DIRECTORY_COMMON, imageName: 'ncn-common', version: env.VERSION, props: props)
                            }
                        }
                    }
                }
                stage('Pre-Install Toolkit') {
                    when {
                        expression { !params.disablePIT }
                    }
                    environment {
                        /*
                    The following variables are for the pit layer:
                    - BUILD_DATE
                    - GIT_HASH
                    - GIT_TAG
                    - PKG_VAR_pit_slug

                    These have to be the same for every pit build between Google and Metal. If these moved into the Google and Metal stages
                    then they would differ by a few seconds. The only way to make them the same in the Jenkinsfile's current state is to define them
                    for all four common builds (ncn-common:google, ncn-common:metal, pit:google, pit:metal).
                */
                        BUILD_DATE = sh(returnStdout: true, script: "date -u '+%Y%m%d%H%M%S'").trim()
                        GIT_HASH = "${GIT_COMMIT[0..6]}"
                        GIT_TAG = sh(returnStdout: true, script: "git fetch origin --tags && git describe --tags --abbrev=0").trim()
                        PKR_VAR_pit_slug = "${GIT_TAG}/${BUILD_DATE}/g${GIT_HASH}"
                    }
                    steps {
                        withCredentials([
                                string(credentialsId: 'sles15-initial-root-password', variable: 'SLES15_INITIAL_ROOT_PASSWORD'),
                                usernamePassword(credentialsId: 'artifactory-algol60', usernameVariable: 'ARTIFACTORY_USER', passwordVariable: 'ARTIFACTORY_TOKEN'),
                                file(credentialsId: 'google-image-manager', variable: 'GOOGLE_APPLICATION_CREDENTIALS'),
                                file(credentialsId: 'google-image-manager', variable: 'GOOGLE_CLOUD_SA_KEY')
                        ]) {
                            script {
                                
                                def base = "sles15-base"
                                def googleSourceArtifact = "vshasta-${base}-${VERSION}"
                                def googleSourceImageFamily = "vshasta-${base}"
                                def sourceImage = "${base}-${VERSION}"
                                def arguments
                                def props
                                def source = "${ARTIFACTS_DIRECTORY_BASE}/${sourceImage}"

                                if (!params.rebuildBaseImage) {
                                    source = "${STABLE_BASE}/${base}/${java.net.URLEncoder.encode("${sourceBuildVersion}", "UTF-8")}/${base}-${java.net.URLEncoder.encode("${sourceBuildVersion}", "UTF-8")}"
                                    if (sourceBuildVersion != "[RELEASE]") {
                                        source = nodeImageHelpers.getArtifactorySourceArtifactFromId(source, sourceBuildVersion)
                                        googleSourceArtifact = nodeImageHelpers.getGoogleCloudSourceArtifactFromId(googleSourceImageFamily, sourceBuildVersion)
                                    } else {
                                        googleSourceArtifact = getGoogleCloudSourceArtifact(
                                                googleCloudSaKey: GOOGLE_CLOUD_SA_KEY,
                                                googleCloudProject: params.googleSourceImageProjectId,
                                                googleCloudFamily: googleSourceImageFamily
                                        )
                                    }
                                    dir("${env.ARTIFACTS_DIRECTORY_BASE}") {
                                        httpRequest(authentication: 'artifactory-algol60', outputFile: "${sourceImage}.qcow2", responseHandle: 'NONE', url: "${source}.qcow2")
                                    }
                                }

                                arguments = "-except='virtualbox-ovf.*' -only='*.pit' -var 'google_source_image_name=${googleSourceArtifact}' -var 'source_iso_uri=${env.ARTIFACTS_DIRECTORY_BASE}/${sourceImage}.qcow2' -var 'ssh_password=${SLES15_INITIAL_ROOT_PASSWORD}' -var 'artifactory_user=${ARTIFACTORY_USER}' -var 'artifactory_token=${ARTIFACTORY_TOKEN}' -var 'cpus=${NPROC}' -var 'memory=${NRAM}' -var 'artifact_version=${VERSION}'"
                                publishCsmImages.build(arguments, 'boxes/pit/')
                                publishCsmImages.prepareArtifacts("${ARTIFACTS_DIRECTORY_PIT}", env.VERSION)

                                props = "build.number=${env.VERSION};build.url=${env.BUILD_URL};vcs.revision-short=${GIT_COMMIT[0..6]};build.source-artifact=${source}"
                                publishCsmImages(pattern: "${ARTIFACTS_DIRECTORY_PIT}", imageName: 'pre-install-toolkit', version: env.VERSION, props: props)
                            }
                        }
                    }
                }
            }
        }
        stage('NCN Node Layers') {
            when {
                expression { env.TAG_NAME == null && (!(BRANCH_NAME ==~ promotionToken) || (BRANCH_NAME ==~ promotionToken && params.buildAndPublish)) }
            }
            parallel {
                stage('Kubernetes') {
                    steps {
                        withCredentials([
                                string(credentialsId: 'sles15-initial-root-password', variable: 'SLES15_INITIAL_ROOT_PASSWORD'),
                                usernamePassword(credentialsId: 'artifactory-algol60', usernameVariable: 'ARTIFACTORY_USER', passwordVariable: 'ARTIFACTORY_TOKEN'),
                                file(credentialsId: 'google-image-manager', variable: 'GOOGLE_APPLICATION_CREDENTIALS'),
                                file(credentialsId: 'google-image-manager', variable: 'GOOGLE_CLOUD_SA_KEY')
                        ]) {
                            script {
                                
                                def base = "ncn-common"
                                def googleSourceArtifact = "vshasta-${base}-${VERSION}"
                                def googleSourceImageFamily = "vshasta-${base}"
                                def sourceImage = "${base}-${VERSION}"
                                def arguments
                                def props
                                def source = "${ARTIFACTS_DIRECTORY_COMMON}/${sourceImage}"

                                if (!params.rebuildCommonImage) {
                                    source = "${STABLE_BASE}/${base}/${java.net.URLEncoder.encode("${sourceBuildVersion}", "UTF-8")}/${base}-${java.net.URLEncoder.encode("${sourceBuildVersion}", "UTF-8")}"
                                    if (sourceBuildVersion != "[RELEASE]") {
                                        source = nodeImageHelpers.getArtifactorySourceArtifactFromId(source, sourceBuildVersion)
                                        googleSourceArtifact = nodeImageHelpers.getGoogleCloudSourceArtifactFromId(googleSourceImageFamily, sourceBuildVersion)
                                    } else {
                                        googleSourceArtifact = getGoogleCloudSourceArtifact(
                                                googleCloudSaKey: GOOGLE_CLOUD_SA_KEY,
                                                googleCloudProject: params.googleSourceImageProjectId,
                                                googleCloudFamily: googleSourceImageFamily
                                        )
                                    }
                                    dir("${env.ARTIFACTS_DIRECTORY_COMMON}") {
                                        httpRequest(authentication: 'artifactory-algol60', outputFile: "${sourceImage}.qcow2", responseHandle: 'NONE', url: "${source}.qcow2")
                                    }
                                }

                                arguments = "-except='virtualbox-ovf.*' -only='*.kubernetes' -var 'google_source_image_name=${googleSourceArtifact}' -var 'source_iso_uri=${env.ARTIFACTS_DIRECTORY_COMMON}/${sourceImage}.qcow2' -var 'ssh_password=${SLES15_INITIAL_ROOT_PASSWORD}' -var 'artifactory_user=${ARTIFACTORY_USER}' -var 'artifactory_token=${ARTIFACTORY_TOKEN}' -var 'cpus=${NPROC}' -var 'memory=${NRAM}' -var 'artifact_version=${VERSION}'"
                                publishCsmImages.build(arguments, 'boxes/ncn-node-images/')
                                publishCsmImages.prepareArtifacts("${ARTIFACTS_DIRECTORY_K8S}", env.VERSION)

                                props = "build.number=${VERSION};build.url=${env.BUILD_URL};vcs.revision-short=${GIT_COMMIT[0..6]};build.source-artifact=${source}"
                                publishCsmImages(pattern: "${ARTIFACTS_DIRECTORY_K8S}", imageName: 'kubernetes', version: env.VERSION, props: props)
                            }
                        }
                    }
                }
                stage('Storage-CEPH') {
                    steps {
                        withCredentials([
                                string(credentialsId: 'sles15-initial-root-password', variable: 'SLES15_INITIAL_ROOT_PASSWORD'),
                                usernamePassword(credentialsId: 'artifactory-algol60', usernameVariable: 'ARTIFACTORY_USER', passwordVariable: 'ARTIFACTORY_TOKEN'),
                                file(credentialsId: 'google-image-manager', variable: 'GOOGLE_APPLICATION_CREDENTIALS'),
                                file(credentialsId: 'google-image-manager', variable: 'GOOGLE_CLOUD_SA_KEY')
                        ]) {
                            script {

                                def base = "ncn-common"
                                def googleSourceArtifact = "vshasta-${base}-${VERSION}"
                                def googleSourceImageFamily = "vshasta-${base}"
                                def sourceImage = "${base}-${VERSION}"
                                def arguments
                                def props
                                def source = "${ARTIFACTS_DIRECTORY_COMMON}/${base}"

                                if (!params.rebuildCommonImage) {
                                    source = "${STABLE_BASE}/${base}/${java.net.URLEncoder.encode("${sourceBuildVersion}", "UTF-8")}/${base}-${java.net.URLEncoder.encode("${sourceBuildVersion}", "UTF-8")}"
                                    if (sourceBuildVersion != "[RELEASE]") {
                                        source = nodeImageHelpers.getArtifactorySourceArtifactFromId(source, sourceBuildVersion)
                                        googleSourceArtifact = nodeImageHelpers.getGoogleCloudSourceArtifactFromId(googleSourceImageFamily, sourceBuildVersion)
                                    } else {
                                        googleSourceArtifact = getGoogleCloudSourceArtifact(
                                                googleCloudSaKey: GOOGLE_CLOUD_SA_KEY,
                                                googleCloudProject: params.googleSourceImageProjectId,
                                                googleCloudFamily: googleSourceImageFamily
                                        )
                                    }
                                    dir("${env.ARTIFACTS_DIRECTORY_COMMON}") {
                                        httpRequest(authentication: 'artifactory-algol60', outputFile: "${sourceImage}.qcow2", responseHandle: 'NONE', url: "${source}.qcow2")
                                    }
                                }

                                arguments = "-except='virtualbox-ovf.*' --only='*.storage-ceph' -var 'google_source_image_name=${googleSourceArtifact}' -var 'source_iso_uri=${env.ARTIFACTS_DIRECTORY_COMMON}/${sourceImage}.qcow2' -var 'ssh_password=${SLES15_INITIAL_ROOT_PASSWORD}' -var 'artifactory_user=${ARTIFACTORY_USER}' -var 'artifactory_token=${ARTIFACTORY_TOKEN}' -var 'cpus=${NPROC}' -var 'memory=${NRAM}' -var 'artifact_version=${VERSION}'"
                                publishCsmImages.build(arguments, 'boxes/ncn-node-images/')
                                publishCsmImages.prepareArtifacts("${ARTIFACTS_DIRECTORY_CEPH}", env.VERSION)

                                props = "build.number=${VERSION};build.url=${env.BUILD_URL};vcs.revision-short=${GIT_COMMIT[0..6]};build.source-artifact=${source}"
                                publishCsmImages(pattern: "${ARTIFACTS_DIRECTORY_CEPH}", imageName: 'storage-ceph', version: env.VERSION, props: props)
                            }
                        }
                    }
                }
            }
        }
        stage('Release') {
            when { tag "*" }
            steps {
                withCredentials([
                        usernamePassword(credentialsId: 'artifactory-algol60', usernameVariable: 'ARTIFACTORY_USER', passwordVariable: 'ARTIFACTORY_TOKEN'),
                        file(credentialsId: 'google-image-manager', variable: 'GOOGLE_CLOUD_SA_KEY')
                ]) {
                    script {
                        /*
                            Use a try/catch block to prevent sles15-base and pit from requiring an administrator to manually build a git-tag. This
                            manual process is tedious, and prone to mistakes, this way the Jenkins pipeline will always try to publish these layers.
                        */
                        try {
                            publishCsmImages.release('sles15-base', GIT_COMMIT[0..6], env.TAG_NAME, GOOGLE_CLOUD_SA_KEY)
                        } catch (err) {
                            echo err.getMessage()
                            echo 'The build attempted to publish a sles15-base image but none was found, this may or may not be expected.'
                        }
                        try {
                            publishCsmImages.release('ncn-common', GIT_COMMIT[0..6], env.TAG_NAME, GOOGLE_CLOUD_SA_KEY)
                        } catch (err) {
                            echo err.getMessage()
                            echo 'The build attempted to publish a ncn-common image but none was found, this may or may not be expected.'
                        }
                        /*
                            These three layers are always built and required for publishing.
                        */
                        publishCsmImages.release('kubernetes', GIT_COMMIT[0..6], env.TAG_NAME, GOOGLE_CLOUD_SA_KEY)
                        publishCsmImages.release('pre-install-toolkit', GIT_COMMIT[0..6], env.TAG_NAME, GOOGLE_CLOUD_SA_KEY)
                        publishCsmImages.release('storage-ceph', GIT_COMMIT[0..6], env.TAG_NAME, GOOGLE_CLOUD_SA_KEY)
                    }
                }
            }
        }
    }
    post('Tests Results') {
        always {
            script {
                if (env.TAG_NAME == null && (!(BRANCH_NAME ==~ promotionToken) || (BRANCH_NAME ==~ promotionToken && params.buildAndPublish))) {
                    // TODO: Each file needs it's own name.
                    def testDirectory = "build-test-results"
                    sh "mkdir -v $testDirectory"
                    sh "find ./output* -name *.xml -exec cp {} $testDirectory/ \\;"
                    sh "ls -l $testDirectory"
                    // A try/catch won't flunk the build; we don't want to flunk the build.
                    try {
                        junit 'build-test-results/test-results-*.xml'
                    } catch (err) {
                        echo err.getMessage()
                        echo "The build didn't have any test results, or the test results were not readable."
                    }
                } else {
                    echo 'No test results available on tag builds or production branch builds.'
                }
            }
        }
    }
}
